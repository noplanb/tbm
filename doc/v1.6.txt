 - Change videoRecording to use the settings I came up with in video_recorder.txt in tbm-ios.
 - Fix Kons video problem and dim recording screen on farhads and kons phones.
 - Swipe abort too short a distance use dp instead of px
 - Always notify but remove the notification from the notifications pane on resume
 - Change tone to the textmessage tone.
 - Server should delete the old videos.
 - Only send viewed event once.
 - Send platform :android when sending push_token.
 - Force a crash while still locking the camera and see if the os never gets it.
 - Handle no connection on register.
 - Delay in starting to record.
 - Distance you have to move off to cancel recording.
 
 Android notification.
 1) Notification banners to the user.
   a) Need to send anytime app is paused. Currently I try to resume the app in those cases. But i think the app can be paused while the screen is off. In that case you dont get a notification and the app does not come on. So you miss the fact that a message came in. This is probably the biggest problem. My bad in designing that way. My phone never turned screen off in all my testing so I thought it made sense but doesnt.
   b) Remove stale notification banners whenever you launch the app. Jill just sees the old ones and thinks nothing new has happened. 
   c) Add notification splash banner to off screen. This will be huge for android. 

 2) Notification unreliability.
   This is not as big a problem but definitely one that has come up in many cases for Kon and some cases with Jill. Often you are connected to wifi but the port for notifications is not allowed by router policy, tcp socket not allowed, or you dont get notification for some other reason. In this case messages are stuck on the server even if you check your app when you think you have good coverage. This is the case for Kon right now with a message stuck on server.
   This can significantly improved with some simple polling on startup. And periodic smart polling when running and you are in a state that is expecting a reply might be even better with a trade off on expense.
   
 3) Retry
   - Upload retry holdoff should max out.
   - When upload is retrying with long holdoff when app comes to foreground it should restart the retry count.
  
   
Architecture change to properly save instance state:
====================================================
Hey Farhad thinking outloud here to get some feedback from you...

On IOS
- There are no services
- The app is the only process it is either running, background or terminated and all initiating actions go through the app_delegate
- I use cocoa managed object facility to save and restore instance state when moving in and out of terminated.
- The app requests and is given background time to handle background downloads and uploads with retry.
- The app is woken in a background state to pre handle notifications. 
- But the necessary objects are always there and there are no IPC issues vis a vis their state as all these actions are initiated through the app delegate which automatically and consistently saves and restores instance state.
- Cocoa managed objects ensures multiple threads can access common objects cleanly.

On Android
- I was new to the environment so I did not make use of the saved instance state bundle. I thought I needed services to deal with the app objects even if the app was destroyed (android version of ios-terminated). I couldnt see a way to do that with saved instance state bundle so I rolled my own active_model like facility to separately save and restore instance state. This active model and its factory are subclassed to the objects I need to persist.
- I allow separate services that run on processes and threads completely independently of the app to access app models. These are for actions like, handling notifications, background uploads and downloads. 
- I need to deal with the Inter Process Coordination aspects of this architecture. It gets to the point I think where not only all writes need to go to file but all reads need to as well since independent asynchronous processes can change the models. And there may be spurious file lock conflicts.
- This is giving me a big headache and it looks like a mixup in this is causing at least one of the crash scenarios Kons phone reported although I dont fully understand it yet. In one of the crash scenarios a notification intent gets null for a model that should exist. Hard to understand how this could happen (perhaps 2 processes trying to access the same file at the same time). But my architecture is a bitch to debug and test.


Some thoughts. 
 - Rolling my own active model and not making use of the frameworks ability to save and restore instance state is a lot of work that I dont need to do and is probably asking for trouble.
 - Having multiple process asynchronously access common models is also an architecture that is difficult to debug and maintain. 

Proposed rearchitecture.
 - Go to an architecture that is much more like IOS.
 - Use the framework to save and restore instance state via the bundle. Tear out all my own active model stuff.
 - All actions on the models read or write are done through only one process: the app activity.
 - Asynchronous services running on other processes are always passed what they need explicitly to perform their tasks. 
 - Asynchronous services running on other processes that feel they need to write the models wake up the app activity through intents and the app activity takes care of the updates.
 - Actions on the models may still be taken on multiple threads but always in the same single app Activity process.

Problem is that it is a huge rewrite. Probably 2 weeks to redo and test.