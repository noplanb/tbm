 USER CONNECTIONS DATABASE
 =========================
 - Invitee doesn't have app
   - Inviter sends an sms directly.
   - Inviter tells server about invite.
   - Sms has a weblink to a site of ours which has a link to the store.
   - Invitee downloads
     - Goes through unknown reg
   - Server recognizes connection
   - App goes to same state as InvitedHasApp.
 - InviteeHasApp
   - Is full
   - Is not full
     - Doesn't want to add inviter
       - Invitee rejects.
       - Inviter gets a notification. 
         - Acknowledges he got the notification in the ui modal and it disappears as does the invite.
     - Wants to add
         - Invitee accepts
         - Both phones go to ui state where connected but no message has been received. 

 - Inviter 
   - Can cancel invite at anytime by the normal process of ClearingTheSquare
   - If cancelled before invitee has seen the invite it looks like he never got one.
   - If cancelled after it looks like a normal entry without any invites.

- Registration unknown user
  - First | Last | Phone
  - Verify phone via sms
  - On verification create 
  - Record has 
     - First, last, phone, userId, authtoken, mailboxkey.
  
- Ways a user record gets in our system
  - Invite
    - Inviter sends sms to a contact in his phonebook.
    - We send the phone, first, last that he sent the sms to back to the server
    - We add missing country code and area code info.
    - We make an invite connection
    - Create the invited user user record in a pending state. 
  - Registration
    - We find or create the user record based on phone number in a pending state
    - We send a loopback sms
    - We compare the code we receive.
    - Make record verified state.
    - Generate an auth token
    - Send it back to the phone.

- If phone looses auth token user has to go through sms loopback verification again.

Entities
  - Users
  - Connections 
    - Invite as state on connections.
  
Scaling this Users|Connections database
  - Will change many orders of magnitude less often than the messaging side
  - We can set a bit in the messaging side which is subject to notification and high frequency polling telling the client to check for changes in the state of connections.
  

MESSAGING DATABASE high bandwidth.
=================================
 - Each user gets half of a mailbox key.
 - The put their half and their connections half through a shared scramble to get the filename or keyname for their mailboxes.
 - Vending machine authentication via token shared algorithm with vending machine.
 
 Entities in the high bandwidth kv (dynamo db)
   - A kv from sender to receiver 
     - is always written by sender
     - Contains I have a new video for you. 
       - Save a time stamp in this field
       - Poller compares this time stamp with his last video to determine if it is new. 
     - Contains the last status for last video you sent to me.
     
 - Sender creates a message
 - Sender uploads directly to s3 in filename created by scrambling mailbox keys for him and reciever.
 - Sender updates 
 

NOTIFICATION SERVER high bandwidth
=================================
 - Authenticate using shared algorithm for creating and authenticating large token.
 - Actions
   - This is my notification token. 
   - I want to send a notification to this user.
 - User is identified by a scramble of his mailbox key.
 - Table has
   - User key
   - Notification key
   - Platform


 
 


    

    