Misc
 - Only send viewed event once.
 - Differentiate on the server between a request that cant be fulfilled now and one that will never be fulfilled because for example the device is asking for a video that will never exist.
 - Fix Kons video problem and dim recording screen on farhads and kons phones.
 - Send platform :android when sending push_token.
 - Handle no connection on register.
 - Delay in starting to record.
 - First upload to the server seems to fail every time now and we go to R1.
 - Fix flicker to black when starting to play. Try putting thumb on top. Try waiting till prepared to show player.
 
 Bugs
 - Uploading shows stuck on phone for android p but no retry.
 
 LongPressTouchHandler
 - Distance you have to move off to cancel recording use dp instead of px
 - Dont crash when you put down 2 fingers
 - Make sure we pass the view where the start happened when we stop or abort.
 - Make sure we always pass a view
 
 New Server API
 - Switch to the ios server api scheme. 
 - Create a random filename for the uploaded file. Send with the file. 
 - Send notification to android with filename to download.
 - Request download with the filename.
 
 Downloading
 - Add retries for downloading
 - Show downloading indicator with retries
 - Distinguish an error condition where the file attempted to download is not available and download is impossible. 404 not found.
 - Restart downloading retries with reset holdoff when app is resumed.
 
 Uploading
 - Upload retry holdoff should max out.
 - When upload is retrying with long holdoff when app comes to foreground it should restart the retry count.
 
 Make models similar to IOS
 - On ios I have all video status stuff in Friend rather than a separate video status handler. Refactor to that scheme on android.
 
 Polling
 
 Android notification. Notification banners to the user.
 - Need to send anytime app is paused. Currently I try to resume the app in those cases. But i think the app can be paused while the screen is off. In that case you dont get a notification and the app does not come on. So you miss the fact that a message came in. This is probably the biggest problem. My bad in designing that way. My phone never turned screen off in all my testing so I thought it made sense but doesnt.
 - Remove stale notification banners whenever you launch the app. Jill just sees the old ones and thinks nothing new has happened. 
 - Add notification splash banner to off screen. This will be huge for android. 
 - Change tone to our custom tone.
   

Notification unreliability.
   This is not as big a problem but definitely one that has come up in many cases for Kon and some cases with Jill. Often you are connected to wifi but the port for notifications is not allowed by router policy, tcp socket not allowed, or you dont get notification for some other reason. In this case messages are stuck on the server even if you check your app when you think you have good coverage. This is the case for Kon right now with a message stuck on server.
   This can significantly improved with some simple polling on startup. And periodic smart polling when running and you are in a state that is expecting a reply might be even better with a trade off on expense.
   
  
   
Architecture change to properly save instance state:
====================================================
Hey Farhad thinking outloud here to get some feedback from you...

On IOS
- There are no services
- The app is the only process it is either running, background or terminated and all initiating actions go through the app_delegate
- I use cocoa managed object facility to save and restore instance state when moving in and out of terminated.
- The app requests and is given background time to handle background downloads and uploads with retry.
- The app is woken in a background state to pre handle notifications. 
- But the necessary objects are always there and there are no IPC issues vis a vis their state as all these actions are initiated through the app delegate which automatically and consistently saves and restores instance state.
- Cocoa managed objects ensures multiple threads can access common objects cleanly.

On Android
- I was new to the environment so I did not make use of the saved instance state bundle. I thought I needed services to deal with the app objects even if the app was destroyed (android version of ios-terminated). I couldnt see a way to do that with saved instance state bundle so I rolled my own active_model like facility to separately save and restore instance state. This active model and its factory are subclassed to the objects I need to persist.
- I allow separate services that run on processes and threads completely independently of the app to access app models. These are for actions like, handling notifications, background uploads and downloads. 
- I need to deal with the Inter Process Coordination aspects of this architecture. It gets to the point I think where not only all writes need to go to file but all reads need to as well since independent asynchronous processes can change the models. And there may be spurious file lock conflicts.
- This is giving me a big headache and it looks like a mixup in this is causing at least one of the crash scenarios Kons phone reported although I dont fully understand it yet. In one of the crash scenarios a notification intent gets null for a model that should exist. Hard to understand how this could happen (perhaps 2 processes trying to access the same file at the same time). But my architecture is a bitch to debug and test.


Some thoughts. 
 - Rolling my own active model and not making use of the frameworks ability to save and restore instance state is a lot of work that I dont need to do and is probably asking for trouble.
 - Having multiple process asynchronously access common models is also an architecture that is difficult to debug and maintain. 

Proposed rearchitecture.
 - Go to an architecture that is much more like IOS.
 - Use the framework to save and restore instance state via the bundle. Tear out all my own active model stuff.
 - All actions on the models read or write are done through only one process: the app activity.
 - Asynchronous services running on other processes are always passed what they need explicitly to perform their tasks. 
 - Asynchronous services running on other processes that feel they need to write the models wake up the app activity through intents and the app activity takes care of the updates.
 - Actions on the models may still be taken on multiple threads but always in the same single app Activity process.

Problem is that it is a huge rewrite. Probably 2 weeks to redo and test.

RESOLUTION: after looking into savedInstanceState it really does not do what I want. So we should:
  - Stick with the active model scheme and save to file. 
  - Never load the access the models from a service running on another thread.
  - Always write to file when changing an attribute (in case of crash before chance to save).
  - 