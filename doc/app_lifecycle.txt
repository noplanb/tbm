QUESTION - How does startActivity due to new intents work into the application lifecycle.
  
  - What happens when new intent comes in when State is:
    - State: Activity shutdown
      - Goes to onCreate()
    - State: Activity running
      - Goes to onPause() -> onNewIntent() -> onResume()
    - State: Activity Stopped but restartable
      - Goes to onNewIntent() -> onRestart() -> onStart() -> onResume()
    - State: Activity Stopped but app processes killed
      - I have never been able to create this but I think it might be responsible for the spurious bug in jills phone. Perhaps we sometimes go to 
        onNewintent() here even though the app processes were killed when it should be going to onCreate() instead.
        
QUESTION - How can we determine if in a particular lifecycle of our app we will be in the foreground or in the background
  - onCreate
    - FOREGROUND - When a user launches our app (not an VR or VS intent)
    - BACKGROUND - When we are launched due to a VR or VS intent and go through onCreate.
  - onNewIntent
    - FOREGROUND - if last state was Pause()
    - BACKGROUND - if last state was Stop()  
  - onStop
    - BACKGROUND - always
  - onRestart
    - BACKGROUND - if last state was onNewIntent
    - FOREGROUND - otherwise (user launched us again)

Architecture:
  - Track foreground vs background:
    - Create a boolean flag isForeground in HomeActivity
    - set as follows
      - onCreate depending on intent
      - onNewIntent depending on lastState 
        - if pause then set to foreground
      - onStop - false

  - Initialization and persistence:
    - onCreate (boot)
      - ActiveModelsHandler.ensureAll()
      - GCM
    - onPause
      - ActiveModelsHandler.saveAll()
      
PROBLEM with above architecture.
With the architecture change as of 1.8 we get the following bug: An intent comes in after a notification to start a download. The next intent comes in immediately thereafter when the download service reports starting the download. That causes us to go through the following cycle in case app was stopped. stop->newIntent->pause->newIntent. Pause->newIntent causes us to think we should be in the foreground and we launch the app when we shouldnt.

TRY: the following algorithm:
  - Basis for algorithm
    - Transition from background to foreground may only happen due to user action. This can happen in several ways:
      1) User clicks on task manager. 
        - NOTE: We must be in stopped state here. 
          - We cant be destroyed because we wouldnt be in the task manager. 
          - We cant be paused becuase the task manager itself would not be showing. 
        - We dont get an intent for this because Android is fucked. But we can detect it because the state change is stop -> restart.
      2) User launches us from icon
         - We get an intent that is not one of our background notification intents. 
      3) User launches us from notification in notification manager 
         - We get an intent that is not one of our background notification intents. 
      4) User launches us from our lock screen notification activity.
         - We get an intent that is not one of our background notification intents. 
    - Transition from Foreground to background. Happens when the app goes to stop state. 
  - Algorithm
    - Set Foreground and Background 
      - Set to Foreground:
        - On any intent that is not one of our FileUpload, download, status intents.
        - On a transition to restart directly from stop.
      - Set to background on Stop. 
  - Home activity actions
    - If in oncreate
      - Told to run in background by intent handler -> finish()
    - If in onNew intent
      - Told to run in background by intent handler -

=======
 Android state idiosyncrasies:
 - Start from task manager does not go through onNewIntent
   - It goes straight from stop to restart.
 - Sending intent while screen is off does not go directly to onNewIntent it follows this ridiculous path:
   - Restart, Start, Resume, Pause, onNewIntent, Stop.
 
  
=======
PROBLEM - Jills phone has a spurious bug where models retrieved from the file system are empty. This is very hard to reproduce though I once saw it on my phone as well. Probably need to try several things and see if it goes away.

POSSIBLE CAUSES
 - Cause: app enters through newIntent() even though it was in a stopped state where app process were killed.
   - Try: ensuring models are loaded on NewIntent.
 - Cause: We have a thread safety issue where VideoStatusHandler is reading the models from file at the same time our activity is writing them onPause for example.
   - Try: In ActiveModelFactory make save and retrieve synchronized. 

=======
PROBLEM - Sometimes when you come back to the app the thumbnails are blacked out. 

POSSIBLE CAUSE
  - Cause - somehow when stopped the activity looses some view state but it is not sent to onCreate() but rather to onStart() when returning so it is not initialized.
  - Try 
    - moving view initialization into onStart 
    - making model initialization lazy in onStart()

=======
PROBLEM - Don't want app to come to the foreground for SentVideoStatus but want it to come to the foreground for VideoReceived.
    